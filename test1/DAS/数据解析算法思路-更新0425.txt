# 解析声纳数据算法介绍

## `.31A`声纳文件

### 构造思路

1.读取`.31A`文件，将文件通过`Byte`格式读取；

2.通过`for`循环与协议文档提供的报文头与报文尾，将每一个完整报文截取，逐次传递给数据解析函数；

3.解析数据，首先将其中`value`部分逐个解析，增加到列表中，再将其他各个字段逐个解析；最后将保存`value`的列表与其他各个字段值保存在字典中；

4.将所有输出的字典数据保存在`json`文件中

## `XTF`声纳文件

### 构造思路

1.读取`.XTF`文件，将文件通过`Byte`格式读取；

2.获取文件总长度，将`.XTF`文件的`XTFFILEHEADER`截取，解析`XTFFILEHEADER`的所有字段，保存在单独的文件头`json`文件中；

3.跳过文件头数据，将`.XTF`文件的`XTFPINGHEADER`与不同通道的`XTFPINGCHANHEADER`数据循环读取，解析所有字段，保存在`jaon`文件中

4.在解析`XTFPINGCHANHEADER`字段的同时，将不同通道的数据生成图片保存(注:若不想保存图片可注释)

## `DAT`Das文件

### `dat`文件介绍

1.`DASNo20CH1Diff_0_2000_240318.dat` 文件名中0_2000代表0到2000的2001个（光纤传感）点位，一个文件是采集光纤`30s`数据，频率`2000Hz`;

设备有两种数据存储形式，差分数据与原始振动数据，若文件名”DASNo20CH1Diff_0_2000_240318.dat“中的Diff含义为差分数据，文件名”DASNo20CH1Raw_0_2000_240318.dat“中的raw含义为原始振动数据。

2.文件中只有数据包，无包头包尾，每一个点的数据解析如下：

```
例：a = b'\x21\x32'
每两个字节解析为一个点，通过小端字节序排列
value = struct.unpack(<h', a)[0]
```
### 构造思路

用来存储后续dat文件二进制数据转化而来的16为有符号整数的数据

分三个文件解析不同内容:

1.`dat_analyze.py`——解析采集的30s光纤数据，通过读取`*.dat`文件，获取文件长度与总数据包量，可以更改需要保存的点位数据，将数据保存至`csv`和点位的`dat`文件中,`csv`文件可以通过下方的`csv_to_waveform.py`转为波形图，`dat`文件可以通过下方的`wav_trans.py`转为音频播放；同时可以选取某一秒数据生成瀑布图保存；

dat文件解析为可分析数组的步骤：
通过阅读通信协议4页、5页，差分数据和原始振动数据在协议里具体数据都是用16位有符号整数（int16）表示，即可编写代码以int16形式读取DAT文件中的二进制数据；
1）定义一个空数组（data_original），定义dat文件总点位数SampleKP(例如0_2000定义位2001），定义自己所需要的起StartKP、始EndKP的点位（可小于等于2001），定义采样频率SampleRate；
2）循环遍历文件夹中所有dat文件，用'int16'(16位有符号整数)形式和总点位数SampleKP读取dat文件，将其读取的数据存储至一个新数组中data_tp；
3）按自己设定的起始点位对data_tp数组进行截取，并存储至一个新数组中data_part；
4）将每个dat文件读取得到的data_part通过2）步骤的循环合并于data_original中，即得到16位有符号整数的DAS数据数组，横纵轴（按自己设定）代表采样数（采样数除以采样频率为采样时间，单位秒）与点位。

2.`csv_to_waveform.py`——将某一个点保存的`csv`文件转为波形图展示并保存；

3.`wav_trans.py`——将某一个点保存的`dat`文件转为音频文件保存

DAS数组瀑布图可视化处理步骤：
1）对原始数组data_original，绘制瀑布图；
2）data_original二维数组由每个点位的一维时序数据组成，则分别对每个点位的一维时序数据进行去噪，循环处理；
3）去噪算法可调用小波阈值去噪函数，利用小波阈值去噪需自行设定小波基函数、分解层数、小波系数阈值以及阈值函数四个参数，可通过试验不同参数组合选取最佳参数组合，绘制去噪后的数组的瀑布图；
4）若目标事件（轨迹、特征）不明显，可对每个点位的各自的去噪后的时序数据进行分组（时间角度上20个、50个、100个等的数据为一组），每组求其方差（或者RMS），每个点位进行处理后在形成一个二维数组，将其二维数组绘制瀑布图；
5）若4）中得到的瀑布图中存在长期的一直存在的高峰异常值，则可对异常值进行剔除（设为0），要找到异常值所在的点位进行去除；
6）异常值去除参考方法：对4）中方差（或者RMS）数组中每个点位的时序上再进行分组，在每组中对每个方差（或者RMS）数据求标准值，对每个小组对应的标准值进行平均值计算，从而得到每个点位对应的一个平均值，将其平均值按照大小排序，在排序中设定位于排序序列百分之多少处为异常比例的阈值，对平均值大于其阈值的点位数据进行剔除。


## `31A`协议位运算说明(已Head_Pos为例)

`byte_high = (b & 0x3E) >> 1`：

这一行代码先将变量 `b` 与 `0x3E` 进行按位与操作，得到的结果再向右移动一位。`0x3E` 是一个16进制数，其二进制表示为 `00111110`，所以这个操作实际上是将 `b` 的二进制表示的第1至第6位提取出来，并将它们向右移动一位。

`byte_low = ((b & 0x01) << 7) | (a & 0x7F)`：

这一行代码首先将 `b` 与 `0x01` 进行按位与操作，再将结果左移7位，然后与 `a` 和 `0x7F` 进行按位与操作，最后将两者的结果进行按位或操作。这个操作实际上是将 `b` 的二进制表示的第0位提取出来，并将它左移7位，然后将 `a` 的二进制表示的低7位提取出来，然后将两者合并。

`Head_Pos = (byte_high << 8) | byte_low`：

这一行代码将 `byte_high` 左移8位，然后与 `byte_low` 进行按位或操作，得到最终结果 `Head_Pos`。


## `XTF`协议字段解析说明

### `DWORD(Double Word)`——双字整数

1.介绍

一个`DWORD`通常由32位组成，即4个字节，常用于存储无符号整数(无说明，默认小端字节序)

2.举例

`XTF`解析文件中`XTFPINGCHANHEADER_2`字段中`NumSamples`的解析：

```
NumSamples = struct.unpack('<I',buf[42:46])[0]
```

其中`<I`表示小端字节序解析，`buf[42:46]`是需要解析的字节序列，`[0]`取出解析结果中的第一个元素(即解析出的无符号整数)

若`buf[42:46] = b'\x33\x01\x00\x00'`,带入计算，`NumSamples=307`

### `WORD`——单字

1.介绍

一个`WORD`通常由16位组成，即2个字节，常用于表示无符号整数(无说明，默认小端字节序)

2.举例

`XTF`解析文件中`XTFPINGCHANHEADER_2`字段中`MillivoltScale`的解析：

```
MillivoltScale = struct.unpack('<H',buf[46:48])[0]
```

其中`<H`表示小端字节序解析，`buf[46:48]`是需要解析的字节序列，`[0]`取出解析结果中的第一个元素(即解析出的无符号整数)

若`buf[46:48] = b'\x22\x00'`,带入计算，`MillivoltScale=34`

### `Short`——短型整数

1.介绍

通常用来表示短整数，占用2个字节(16位)

2.举例

`XTF`解析文件中`XTFPINGHEADER`字段中`FishPositionDeltaX`的解析：

```
FishPositionDeltaX = struct.unpack('<h',buffer[240:242])[0]
```

其中`<h`表示短整数的小端字节序解析，`buffer[240:242]`是需要解析的字节序列，`[0]`取出解析结果中的第一个元素(即解析出的无符号整数)

若`buffer[240:242] = b'\x31\x01'`,带入计算，`FishPositionDeltaX=305`

### `Float`——单精度浮点数

1.介绍

单精度浮点数通常占用4个字节（32位），可以表示大约 7 位的有效数字(无说明，默认小端字节序)

2.举例

`XTF`解析文件中`XTFPINGCHANHEADER_2`字段中`ContactTimeOffTrack`的解析：

```
ContactTimeOffTrack = struct.unpack('<f',buf[48:52])[0]
```

其中`<f`表示单精度的小端字节序解析，`buf[48:52]`是需要解析的字节序列，`[0]`取出解析结果中的第一个元素(即解析出的无符号整数)

若`buf[48:52] = b'\x33\x23\x31\x43'`,带入计算，`ContactTimeOffTrack=177.1374969482422`

### `DOUBLE`——双精度浮点数

1.介绍

双精度浮点数通常占用8个字节（64位），较高精度的计算中，通常会使用双精度浮点数来存储数据(无说明，默认小端字节序)

2.举例

`XTF`解析文件中`XTFPINGHEADER`字段中`ShipYcoordinate`的解析：

```
ShipYcoordinate = struct.unpack('<d',buffer[128:136])[0]
```

其中`<d`表示双精度浮点数的小端字节序解析，`buffer[128:136]`是需要解析的字节序列，`[0]`取出解析结果中的第一个元素(即解析出的无符号整数)

若`buffer[128:136] = b'\x33\x23\x31\x45\x21\x44\x55\x40'`,带入计算，`ShipYcoordinate=85.06453065680107`

### `BYTE`

1.介绍

一般都指一个字节，通常用来存储无符号整数(单字节解析大小端字节序都可).

2.举例

`XTF`解析文件中`XTFPINGCHANHEADER_2`字段中`ContactCloseNumber`的解析：

```
ContactCloseNumber = int.from_bytes(buf[52:53],'little')
```

`int.from_bytes`函数将一个字节的数据转换为整数，`buf[52:53]`表示要转换的字节序列，`little`表示使用小端字节序

若`buf[48:52] = b'\x33'`,带入计算，`ContactCloseNumber=51`.

## Struct模块

1.大写字母表示无符号整数类型：

`B`：无符号字节（`unsigned char`）

`H`：无符号短整型（`unsigned short`）

`I`：无符号整型（`unsigned int`）

`L`：无符号长整型（`unsigned long`）

2.小写字母表示有符号整数类型：

`b`：有符号字节（`signed char`）

`h`：有符号短整型（`short`）

`i`：有符号整型（`int`）

`l`：有符号长整型（`long`）

3.浮点数类型

`f`：单精度浮点数（`float`）

`d`：双精度浮点数（`double`）

4.`<`与`>`

`<`：表示使用小端字节序（`little-endian`），即最低有效字节存储在最低地址

`>`：表示使用大端字节序（`big-endian`），即最高有效字节存储在最低地址

